[{"path":"index.html","id":"intro","chapter":"Introduction to the Practical","heading":"Introduction to the Practical","text":"part practical module - Essentials Mathematics Statistics (EMS) part MSc Bioinformatics University Birmingham.website hosts practicals module, covers:Sampling random variableProbability RLinear regressionPrincipal Component Analysis (PCA)Multivariate RegressionGeneralised Linear Models","code":""},{"path":"index.html","id":"how-to-use-these-resources","chapter":"Introduction to the Practical","heading":"0.1 How to use these resources","text":"Section 2 covers basic concepts using R Rstudio. already covered , refresher.Section 3 contains link one locations can download data .sections contain content practical go .","code":""},{"path":"getting-started-in-r-and-rstudio.html","id":"getting-started-in-r-and-rstudio","chapter":"Getting started in R and Rstudio","heading":"Getting started in R and Rstudio","text":"already started working R, just core principles revisited. Ensure understand required knowledge covered module.","code":""},{"path":"getting-started-in-r-and-rstudio.html","id":"r-scripts","chapter":"Getting started in R and Rstudio","heading":"0.2 R scripts","text":"entering running code R command line effective simple. technique limitations. time want execute set commands, re-enter command line. Complex commands potentially subject typographical errors, necessitating re-entered correctly. Repeating set operations requires re-entering code stream. Fortunately, R RStudio provide method mitigate issues. R scripts solution. script simply text file containing set commands comments. script can saved used later re-execute saved commands. script can also edited can execute modified version commands.","code":""},{"path":"getting-started-in-r-and-rstudio.html","id":"creating-an-r-script","chapter":"Getting started in R and Rstudio","heading":"0.3 Creating an R script","text":"easy create new script RStudio. can open new empty script clicking New File icon upper left main RStudio toolbar. icon looks like white square white plus sign green circle. Clicking icon opens New File Menu. Click R Script menu option script editor open empty script.new script opens Script Editor panel, script ready text entry, RStudio session look like .easy example familiarize Script Editor interface. Type following code new script (later topics explain specific code components )., now first R script. Notice editor places number front line code. line numbers can helpful work code. proceeding executing code, good idea learn save script.","code":"    # this is my first R script\n    # do some things\n    x = 34\n    y = 16\n    z = x + y   # addition\n    w = y/x     # division\n    # display the results\n    x\n    y\n    z\n    w\n    # change x\n    x = \"some text\"\n    # display the results\n    x\n    y\n    z\n    w"},{"path":"getting-started-in-r-and-rstudio.html","id":"saving-an-r-script","chapter":"Getting started in R and Rstudio","heading":"0.4 Saving an R script","text":"can save script clicking Save icon top Script Editor panel. , Save File dialog open.","code":""},{"path":"getting-started-in-r-and-rstudio.html","id":"executing-code-in-an-r-script","chapter":"Getting started in R and Rstudio","heading":"0.5 Executing code in an R script","text":"can run code R script easily. Run button Script Editor panel toolbar run either current line code block selected code. can use First script.R code gain familiarity functionality.Place cursor anywhere line 3 script \\[x = 34\\]. Now press Run button Script Editor panel toolbar. Three things happen: 1) code transferred command console, 2) code executed, 3) cursor moves next line script. Press Run button three times. RStudio executes lines 4, 5, 6 script.Now run set code commands . Highlight lines 8, 9, 10, 11 script.Highlighting accomplished similar may familiar word processor applications. click left mouse button beginning text want highlight, hold mouse button drag cursor end text release button. four lines code highlighted, click editor Run button. four lines code executed command console. takes run script code RStudio.","code":""},{"path":"getting-started-in-r-and-rstudio.html","id":"comments-in-an-r-script-documenting-your-code","chapter":"Getting started in R and Rstudio","heading":"0.5.1 Comments in an R script (documenting your code)","text":"finishing topic, one final concept understand. always good idea place comments code. help understand code meant . become helpful reopen code wrote weeks ago trying work . saying, “Real programmers document code. hard write, hard understand” meant dark joke, coding style guide.comment R code begins # symbol. code First script.R contains several examples comments. Lines 1, 2, 7, 12, 14 image comment lines. line text starts # treated comment ignored code execution. Lines 5 6 image contain comments end. text # treated comment ignored execution.Notice RStudio editor shows comments colored green. green color helps focus code get confused comments.Besides using comments help make R code easily understood, can use # symbol ignore lines code developing code stream. Simply place # front line want ignore. R treat lines comments ignore . want include lines code execution, remove # symbols code executable . technique allows change code execute without retype deleted code.","code":""},{"path":"data-sets.html","id":"data-sets","chapter":"Data sets","heading":"Data sets","text":"practical datasets required, find data required week two practicals data folder . Links individual datasets requried can found beginning practical Canvas.\n","code":""},{"path":"simulating-random-numbers.html","id":"simulating-random-numbers","chapter":"1 Simulating random numbers","heading":"1 Simulating random numbers","text":"number functions R can use simulate random numbers according different probability distributions.function sample allows take sample specified size elements vector xusing sampling without replacement. can use ?sample read documentation describing command.following, use sample function make 10,000 draws set numbers 1, 2, 3 4 display distribution sampled values using histogram.First, define vector called x contains numbers 1, 2, 3, 4. function c allows us combine four numbers together one vector:now use function sample pick four numbers x 10,000 times. result, 10,000 numbers chosen, store :Lets plot histogram values picked:picked number equal probability histogram shows number equally likely chosen.","code":"x <- c(1, 2, 3, 4)out <- sample(x, 10000, replace=TRUE)hist_out <- hist(out, main = '', xlab = 'Values', ylab = 'Frequency')"},{"path":"simulating-random-numbers.html","id":"exercise","chapter":"1 Simulating random numbers","heading":"1.1 Exercise","text":"","code":""},{"path":"simulating-random-numbers.html","id":"question","chapter":"1 Simulating random numbers","heading":"1.1.1 Question","text":"difference output out1 out2 following piece code?","code":"x <- c( 1, 2, 2, 3, 4, 1, 6, 7, 8, 10, 5, 5, 1, 4, 9 )\nout1 <- sample(x, 10, replace=FALSE)\nout2 <- sample(x, 10, replace=TRUE)"},{"path":"simulating-random-numbers.html","id":"solution","chapter":"1 Simulating random numbers","heading":"1.1.2 Solution","text":"option replace=TRUE activates sampling replacement (.e. numbers picked put back can picked ).option replace=FALSE activates sampling without replacement (.e. numbers picked put back picked ).","code":""},{"path":"simulating-random-numbers.html","id":"exercise-1","chapter":"1 Simulating random numbers","heading":"1.2 Exercise","text":"Use sample sample.int function simulate values rolls unbiased six-sided die. Show distribution values obtain consistent unbiased die.Hint 1: Type ?sample.int console get help function.Hint 2: may find useful use function table. Type ?table console get help function.gives uniform distribution numbers 1-6. function sample.int specialised version sample sampling integers. Many R libraries specialised versions general functions specific tasks certain conditions.","code":"rolls_from_sample = sample(c(1:6), size=5000, replace=TRUE)\nrolls_from_sample.int = sample(6, size=5000, replace=TRUE)\n\ntable(rolls_from_sample)#> rolls_from_sample\n#>   1   2   3   4   5   6 \n#> 802 826 812 874 835 851table(rolls_from_sample.int)#> rolls_from_sample.int\n#>   1   2   3   4   5   6 \n#> 817 823 847 812 842 859"},{"path":"markov-chains.html","id":"markov-chains","chapter":"2 Markov Chains","heading":"2 Markov Chains","text":"now look Markov Chain. covered lectures based basic principles covered able use simulations.random process known Markov property (Markov process) probability going next state depends current state past states. Markov process memoryless property store property memory past states.Markov process operates within specific (finite) set states, called Markov Chain.Markov Chain defined three properties:state space: set values states process existA state space: set values states process existA transition matrix: defines probability moving one state another stateA transition matrix: defines probability moving one state another stateA current state probability distribution: defines probability one states start processA current state probability distribution: defines probability one states start processConsider following example two states describing weather particular day: () Sunny (ii) Rainy. arrow denotes probability going one state another course day. example, currently sunny, probability raining next day 0.6. Conversely, raining, probability become sunny next day 0.7 0.3 continue raining.transition matrix can written following R:creates 2 x 2 matrix consisting transition probabilities shown diagram.Suppose want simulate sequence 30 days weather patterns days. Assuming day 0 currently sunny, can following:","code":"transitionMatrix = matrix(c(0.4, 0.6, 0.7, 0.3), nrow=2, ncol=2, byrow=TRUE)\nprint(transitionMatrix)#>      [,1] [,2]\n#> [1,]  0.4  0.6\n#> [2,]  0.7  0.3# initial state - it is [1] sunny or [2] rainy\nstate <- 1\nweather_sequence <- rep(0, 30) # vector to store simulated values\nfor (day in 1:30) { # simulate for 30 days\n  pr <- transitionMatrix[state, ] # select the row of transition probabilities\n\n  # sample [1] or [2] based on the probs pr\n  state = sample(c(1, 2), size = 1, prob = pr)\n  weather_sequence[day] <- state # store the sampled state\n}\n\n# print the simulated weather sequence\nprint(weather_sequence)#>  [1] 2 1 2 2 2 1 2 1 2 1 2 2 2 2 2 2 1 1 2 2 1 1 2 2 1 2 2 2\n#> [29] 1 1"},{"path":"markov-chains.html","id":"exercise-mc","chapter":"2 Markov Chains","heading":"2.1 Exercise MC","text":"Can extend example three-state model?Note, diagram (intentionally) misses self-transitions. able infer probabilities given otherwise add one!","code":""},{"path":"mc-solution.html","id":"mc-solution","chapter":"Solution: 3 state Markov Chain","heading":"Solution: 3 state Markov Chain","text":"Set 3x3 transition matrix:Note ordering states arbitrary used convention State 1 Sunny, State 2 Rainy State 3 Cloudy means probabilities completed order transition matrix. just need consistent.","code":"transitionMatrix = matrix(c(0.7, 0.2, 0.1,\n                            0.3, 0.3, 0.4,\n                            0.6, 0.2, 0.2), nrow=3, ncol=3, byrow=TRUE)\n\n# Check matrix set-up correctly\nprint(transitionMatrix)#>      [,1] [,2] [,3]\n#> [1,]  0.7  0.2  0.1\n#> [2,]  0.3  0.3  0.4\n#> [3,]  0.6  0.2  0.2state <- 1 # initial state - it is [1] sunny, [2] rainy and [3] cloudy\nweather_sequence <- rep(0, 30) # vector to store simulated values\n\n# simulate for 30 days\nfor (day in 1:30) {\n  pr <- transitionMatrix[state, ] # select the row of transition probabilities\n\n  # sample [1-3] based on the probs pr\n  state <- sample(c(1, 2, 3), size = 1, prob = pr)\n  weather_sequence[day] <- state # store the sampled state\n}\nprint(weather_sequence)#>  [1] 1 1 2 3 1 1 2 2 3 3 2 3 2 3 2 2 3 1 1 1 1 1 1 1 1 1 1 1\n#> [29] 1 3"},{"path":"a-monopoly-simulation.html","id":"a-monopoly-simulation","chapter":"3 A Monopoly simulation","heading":"3 A Monopoly simulation","text":"Now use simulate simplified games Monopoly (https://en.wikipedia.org/wiki/Monopoly_(game)). addition, also many tutorials guides Web describing produce computer simulations Monopoly. welcome read use examples inspire work.","code":""},{"path":"a-monopoly-simulation.html","id":"moving-around-the-board","chapter":"3 A Monopoly simulation","heading":"3.1 Moving around the board","text":"Monopoly board 40 spaces. Players take turns roll two dice traverse around board according sum dice values.Use following code example simulate turns single player:increasing number turns taken, distribution set simulated board positions converge towards? Show graphically using histogram function.","code":"num_turns <- 100000 # number of turns to take\n\ncurrent_board_position <- 0 # start on the GO space\n\nmove_size <- rep(0, num_turns)\npositions_visited <- rep(0, num_turns)\n\n# use a for loop to simulate a number of turns\nfor (turn in 1:num_turns) {\n\n  # roll two dice\n  die_values <- sample(c(1:6), 2, replace = TRUE)\n\n  # move player position\n\n  # number of positions to move\n  plus_move <- sum(die_values)\n\n  # compute new board position\n  new_board_position <- current_board_position + plus_move\n\n  # update board position (this corrects for the fact the board is circular)\n  current_board_position <- (new_board_position %% 40)\n\n  # store position visited\n  positions_visited[turn] <- current_board_position\n\n}hist(positions_visited, breaks = seq(0, 40, len = 41), right = FALSE)"},{"path":"a-monopoly-simulation.html","id":"going-to-jail","chapter":"3 A Monopoly simulation","heading":"3.2 Going to Jail","text":"player lands Go Jail space must move immediately Jail space. Extend code include possibility going jail. , assume jail, player continues normal next turn.","code":" num_turns <- 100000 # number of turns to take\n\ncurrent_board_position <- 0 # start on the GO space\ngo_to_jail_position <- 30 # the go to jail space\njail_position <- 10 # jail space\n\nmove_size <- rep(0, num_turns)\npositions_visited <- rep(0, num_turns)\n\n# use a for loop to simulate a number of turns\nfor (turn in 1:num_turns) {\n\n  # roll two dice\n  die_values <- sample(c(1:6), 2, replace = TRUE)\n\n  # move player position\n\n  # number of positions to move\n  plus_move <- sum(die_values)\n\n  # compute new board position\n  new_board_position <- current_board_position + plus_move\n\n  # if land on GO TO JAIL square, then go backwards to the JAIL square\n  if (new_board_position == go_to_jail_position) {\n    new_board_position <- jail_position\n  }\n\n  # update board position (this corrects for the fact the board is circular)\n  current_board_position <- (new_board_position %% 40)\n\n  # store position visited\n  positions_visited[turn] <- current_board_position\n\n}"},{"path":"a-monopoly-simulation.html","id":"exercise-2","chapter":"3 A Monopoly simulation","heading":"3.3 Exercise","text":"distribution board positions long game?Can explain result qualitatively?Discuss neighbour instructor.","code":"hist(positions_visited, breaks = seq(0, 40, len = 41), right = FALSE)"},{"path":"a-monopoly-simulation.html","id":"exercise-3","chapter":"3 A Monopoly simulation","heading":"3.4 Exercise","text":"can also go jail, roll three doubles (dice value) row. Update code allow possibility going Jail three doubles. distribution board positions change?","code":""},{"path":"a-monopoly-simulation.html","id":"exercises-extend-the-game","chapter":"3 A Monopoly simulation","heading":"3.5 Exercises: Extend the game","text":"Now consider building complex Monopoly simulation incorporating complex aspects game :purchase propertiesa ledger playerchance community cardsYou need think carefully simplifying assumptions make make task achievable. -ambitious. example, might initially assume players build houses/hotels properties.questions answer simulations:many turns take properties purchased?best properties buy?long take winner determined?\n\nShow Solution\n","code":""},{"path":"monopolySol.html","id":"monopolySol","chapter":"Solutions: Monopoly","heading":"Solutions: Monopoly","text":"","code":""},{"path":"monopolySol.html","id":"id_3doubleMon","chapter":"Solutions: Monopoly","heading":"3.6 Solution Exercise 1: Rolling three doubles","text":"can also go jail, roll three doubles (dice value) row. Update code allow possibility going Jail three doubles. distribution board positions change?best process add new feature existing code. way can compare results without new feature.Adding rolling doubles feature doesn’t seem change much. might expect since rolling three doubles unlikely event!","code":"num_turns <- 100000 # number of turns to take\n\ncurrent_board_position <- 0 # start on the GO space\ngo_to_jail_position  <- 30 # the go to jail space\njail_position <- 10 # jail space\n\nmove_size <- rep(0, num_turns)\npositions_visited <- rep(0, num_turns)\n\n# use a for loop to simulate a number of turns\nfor (turn in 1:num_turns) {\n\n  # set double counter to zero\n  double_counter <- 0\n\n  # roll (max) three times\n  for (j in 1:3){\n\n    # roll two dice\n    die_values <- sample(c(1:6), 2, replace = TRUE)\n\n    # if we have rolled a double for the third time, we proceed straight to jail\n    if ((die_values[1] == die_values[2]) & (double_counter == 2 )) {\n      current_board_position <- jail_position\n      break\n    }\n\n    # otherwise\n\n    # move player position\n\n    # number of positions to move\n    plus_move <- sum(die_values)\n\n    # compute new board position\n    new_board_position <- current_board_position + plus_move\n\n    # if land on GO TO JAIL square, then go backwards to the JAIL square\n    if (new_board_position == go_to_jail_position) {\n      new_board_position <- jail_position\n    }\n\n    # update board position (this corrects for the fact the board is circular)\n    current_board_position <- (new_board_position %% 40)\n\n    # break out of loop if we roll a non-double\n    if (die_values[1] != die_values[2]) {\n      break\n    } else { # increment double counter\n      double_counter <- double_counter + 1\n    }\n\n  }\n\n  # store final position visited\n  positions_visited[turn] <- current_board_position\n\n\n}\n\n\nhist(positions_visited, breaks = seq(0, 40, len = 41), right = FALSE)"},{"path":"monopolySol.html","id":"monopolyExtSol","chapter":"Solutions: Monopoly","heading":"3.7 Solution Exercise 2: Monopoly Extension","text":"example, following simple extension previous example adds features record properties purchased. simulation constructed based assumption players always buys free property land .","code":"num_games <- 1000 # number of games to play\nnum_turns <- 1000 # number of turns to take\n\ncurrent_board_position <- 0 # start on the GO space\ngo_to_jail_position <- 30 # the go to jail space\njail_position <- 10 # jail space\n# vector of squares containing properties\nproperties_that_can_be_bought <- c(1, 3, 5, 6, 8, 9, 11, 12, 13, 14, 15, 16,\n   18, 19, 21, 23, 24, 25, 26, 27, 28, 29, 31, 32, 34, 35, 37, 39)\n\n\n# vector to store number of turns to buy all properties\ntime_to_buy_all_properties <- rep(0, num_games)\n\n# simulate multiple games\nfor (game in 1:num_games) {\n\n  positions_visited <- rep(0, num_turns)\n  positions_purchased <- rep(0, 40)\n  properties_bought <- rep(0, num_turns)\n\n  # use a for loop to simulate a number of turns\n  for (turn in 1:num_turns) {\n\n    # roll two dice\n    die_values <- sample(c(1:6), 2, replace = TRUE)\n\n    # move player position\n\n    # number of positions to move\n    plus_move <- sum(die_values)\n\n    # compute new board position\n    new_board_position <- current_board_position + plus_move\n\n    # if land on GO TO JAIL square, then go backwards to the JAIL square\n    if (new_board_position == go_to_jail_position) {\n      new_board_position <- jail_position\n    }\n\n    # update board position (this corrects for the fact the board is circular)\n    current_board_position <- (new_board_position %% 40)\n\n    # if we can on a square that can be purchased and which has not been\n    # purchased (note R uses 1-indexing for arrays)\n    if (positions_purchased[current_board_position+1] == 0) {\n      if (current_board_position %in% properties_that_can_be_bought) {\n        positions_purchased[current_board_position + 1] <- 1\n      }\n    }\n\n    # store position visited\n    positions_visited[turn] <- current_board_position\n\n    # store number of properties bought\n    properties_bought[turn] <- sum(positions_purchased)\n\n    # check if all properties are gone\n    if (properties_bought[turn] == length(properties_that_can_be_bought)) {\n      time_to_buy_all_properties[game] <- turn\n      break\n    }\n\n\n  }\n\n}\n\nhist(time_to_buy_all_properties, breaks = 20)"},{"path":"monte-carlo-methods.html","id":"monte-carlo-methods","chapter":"4 Monte Carlo Methods","heading":"4 Monte Carlo Methods","text":"Monte Carlo (MC) simulations provide means model problem apply brute force computational power achieve solution - randomly simulate model get answer. idea similar went lecture. best way explain just run bunch examples, lets go!bad! Monte Carlo estimate close true value.","code":""},{"path":"monte-carlo-methods.html","id":"integration","chapter":"4 Monte Carlo Methods","heading":"4.1 Integration","text":"start basic integration. required know perform integration hand, context continuous RVs understand perform integration using MC means. Throughout exercise try relate back saw lecture information integral provides.Suppose instance Normal distribution mean 1 standard deviation 2 want find integral (area curve) 1 3:\\[\n\\int_1^3 \\frac{1}{10 \\sqrt{2\\,\\pi}}\\, e^{- \\frac{(x - 1)^2}{2\\times 2^2}}dx\n\\]can visualise follows:done calculus - worry. going write Monte Carlo approach estimating integral require knowledge calculus!method relies able generate samples distribution counting many values fall 1 3. proportion samples fall range total number samples gives area.First, create new R script Rstudio. Next define number samples obtain. Lets start choosing 1,000Now use R function rnorm simulate 100 numbers Normal distribution mean 1 standard deviation 2:Lets estimate integral 1 3 counting many samples value range:result get :exact answer given using cumulative distribution function pnorm R given :pnorm gives integral Normal distribution (case mean 1 standard deviation 2) negative infinity value specified q.first call pnorm(q=3, mean=1, sd=2) gives us integral:second call pnorm(q=1, mean=1, sd=2) gives us integral:Therefore difference gives us integral interest.","code":"n <- 1000 # number of samples to takesims <- rnorm(n, mean = 1, sd = 2) # simulated normally distributed numbers# find proportion of values between 1-3\nmc_integral <- sum(sims >= 1 & sims <= 3) / nprint(mc_integral)#> [1] 0.338mc_exact = pnorm(q=3, mean=1, sd=2) - pnorm(q=1, mean=1, sd=2)\nprint(mc_exact)#> [1] 0.3413447"},{"path":"monte-carlo-methods.html","id":"mc-accuracy","chapter":"4 Monte Carlo Methods","heading":"4.2 Exercise: MC accuracy","text":"Try increasing number simulations see accuracy improves?Can draw graph number MC samples vs accuracy?","code":""},{"path":"monte-carlo-methods.html","id":"approximating-the-binomial-distribution","chapter":"4 Monte Carlo Methods","heading":"4.3 Approximating the Binomial Distribution","text":"flip coin 10 times want know probability getting 3 heads. trivial problem using Binomial distribution suppose forgotten never learned first place.Lets solve problem Monte Carlo simulation. use common trick representing tails 0 heads 1, simulate 10 coin tosses 100 times see often happens.MC estimate probability \\(P(X>3)\\) getwhich can compare R’s built-Binomial distribution function:","code":"runs <- 100 # number of simulations to run\n\ngreater_than_three <- rep(0, runs) # vector to hold outcomes\n\n# run 100 simulations\nfor (i in 1:runs) {\n\n  # flip a coin ten times (0 - tail, 1 - head)\n  coin_flips <- sample(c(0, 1), 10, replace = T)\n\n  # count how many heads and check if greater than 3\n  greater_than_three[i] <- (sum(coin_flips) > 3)\n}\n\n# compute average over simulations\npr_greater_than_three <- sum(greater_than_three) / runsprint(pr_greater_than_three)#> [1] 0.82print(pbinom(3, 10, 0.5, lower.tail = FALSE))#> [1] 0.828125"},{"path":"monte-carlo-methods.html","id":"problem-mc-binomial","chapter":"4 Monte Carlo Methods","heading":"4.4 Problem: MC Binomial","text":"Try increasing number simulations see accuracy improves?Can plot accuracy varies function number simulations? (hint: see previous section)","code":""},{"path":"monte-carlo-methods.html","id":"monte-carlo-expectations","chapter":"4 Monte Carlo Methods","heading":"4.5 Monte Carlo Expectations","text":"Now consider slightly different problem. Consider following spinner. spinner spun randomly probability 0.5 landing yellow 0.25 landing red blue respectively.rules game landing yellow gain 1 point,* red* lose 1 point blue gain 2 points. can easily calculate expected score. THINKHow relate probabilities? random variable type RV dealing ?Let \\(X\\) denote random variable associated score spin :\\[\n    E[X] = \\frac{1}{2} \\times 1 + \\frac{1}{4} \\times (-1) + \\frac{1}{4} \\times 2 = 0.75\n\\]","code":""},{"path":"monte-carlo-methods.html","id":"mc-expectation-1","chapter":"4 Monte Carlo Methods","heading":"4.6 Exercise: MC Expectation 1","text":"ask challenging question :20 spins probability less 0 points?“might solve ?course, methods analytically solve type problem time even explained already written simulation!solve Monte Carlo simulation need sample Spinner 20 times, return 1 0 wise return 0. repeat 10,000 times see often happens!","code":""},{"path":"monte-carlo-methods.html","id":"using-functions","chapter":"4 Monte Carlo Methods","heading":"4.7 Using Functions","text":"First, going introduce concept function. encountered already module. piece code encapsulated can refer repeated via name function rather repeatedly writing lines code. like learn functions R, can read tutorial software carpentry lesson.function write simulate one game indicated return whether number points less zero.","code":"# simulates a game of 20 spins\nplay_game <- function(){\n    # picks a number from the list (1, -1, 2)\n    # with probability 50%, 25% and 25% twenty times\n  results <- sample(c(1, -1, 2), 20, replace = TRUE, prob = c(0.5, 0.25, 0.25))\n\n  # function returns whether the sum of all the spins is < 1\n  return(sum(results) < 0)\n}"},{"path":"monte-carlo-methods.html","id":"simulating-from-function","chapter":"4 Monte Carlo Methods","heading":"4.8 Simulating from function","text":"Now can use function loop play game 100 times:can compute probability , twenty spins, less zero points:probability low. surprising since 25% chance getting point deduction spin 75% chance gaining points. Try increase number simulation runs see can detect games find negative score.","code":"runs <- 100 # play the game 100 times\n\nless_than_zero <- rep(0, runs) # vector to store outcome of each game\nfor (it in 1:runs) {\n  # play the game by calling the function and store the outcome\n  less_than_zero[it] <- play_game()\n}prob_less_than_zero <- sum(less_than_zero)/runs\nprint(prob_less_than_zero)#> [1] 0"},{"path":"monte-carlo-methods.html","id":"mc-expectation-2","chapter":"4 Monte Carlo Methods","heading":"4.9 Exercise: MC Expectation 2","text":"Modify code allow calculate expected number points 20 spins.Simulate game maximum 20 spins go “bust” hit negative score take account compute expected end game score.","code":""},{"path":"solution-monte-carlo.html","id":"solution-monte-carlo","chapter":"Solution: Monte Carlo","heading":"Solution: Monte Carlo","text":"","code":""},{"path":"solution-monte-carlo.html","id":"solution-mc-accuracy","chapter":"Solution: Monte Carlo","heading":"4.10 Solution: MC accuracy","text":"First let’s increase number simulations accuracyNext, plot results. make use ggplot2 library create nice plots without much effort. input need data.frame need create one based data.shows number Monte Carlo samples increased, accuracy increases (.e. difference estimated integral value real values converges zero). addition, variability integral estimates across different simulation runs reduces.","code":"sample_sizes <- c(10, 50, 100, 250, 500, 1000) # try different sample sizes\nn_sample_sizes <- length(sample_sizes) # number of sample sizes to try\nrpts <- 100 # number of repeats for each sample size\naccuracy <- rep(0, n_sample_sizes) # vector to record accuracy values\naccuracy_sd <- rep(0, n_sample_sizes) # vector to record accuracy sd values\n\n# for each sample size\nfor (i in 1:n_sample_sizes) {\n\n  sample_sz <- sample_sizes[i] # select a sanmple size to use\n\n  # vector to store results from each repeat\n  mc_integral <- rep(0, rpts)\n  for (j in 1:rpts){\n    # simulated normally distributed numbers\n    sims <- rnorm(sample_sz, mean = 1, sd = 2)\n    # find proportion of values between 1-3\n    mc_integral[j] <- sum(sims >= 1 & sims <= 3) / sample_sz\n  }\n\n  # compute average difference between integral estimate and real value\n  accuracy[i] <- mean(mc_integral - mc_exact)\n  # compute sd difference between integral estimate and real value\n  accuracy_sd[i] <- sd(mc_integral - mc_exact)\n\n}\n\nprint(accuracy)#> [1]  0.0166552539  0.0080552539  0.0038552539 -0.0013047461\n#> [5] -0.0013047461 -0.0004747461print(accuracy_sd)#> [1] 0.16828307 0.07160244 0.04738580 0.02876864 0.02068715\n#> [6] 0.01497921print(accuracy + accuracy_sd)#> [1] 0.18493832 0.07965769 0.05124105 0.02746390 0.01938240\n#> [6] 0.01450447# load ggplot\nlibrary(ggplot2)\n\n# create a data frame for plotting\ndf <- data.frame(sample_sizes, accuracy, accuracy_sd)\n\nprint(df)#>   sample_sizes      accuracy accuracy_sd\n#> 1           10  0.0166552539  0.16828307\n#> 2           50  0.0080552539  0.07160244\n#> 3          100  0.0038552539  0.04738580\n#> 4          250 -0.0013047461  0.02876864\n#> 5          500 -0.0013047461  0.02068715\n#> 6         1000 -0.0004747461  0.01497921# use ggplot to plot lines for the mean accuracy and error bars\n# using the std dev\nggplot(df, aes(x = sample_sizes, y = accuracy)) +\n  geom_line() +\n  geom_point() +\n  geom_errorbar(\n      aes(ymin = accuracy - accuracy_sd, ymax = accuracy + accuracy_sd),\n          width = .2,\n          position = position_dodge(0.05)) +\n  ylab(\"Estimate-Exact\") +\n  xlab(\"Run\")"},{"path":"solution-monte-carlo.html","id":"mc-expectation","chapter":"Solution: Monte Carlo","heading":"4.11 MC Expectation","text":"","code":""},{"path":"solution-monte-carlo.html","id":"solution-mc-expectation-1","chapter":"Solution: Monte Carlo","heading":"4.11.1 Solution: MC Expectation 1","text":"","code":"# simulates a game of 20 spins\nplay_game <- function() {\n    # picks a number from the list (1, -1, 2)\n    #  with probability 50%, 25% and 25% twenty times\n  results <- sample(c(1, -1, 2), 20, replace = TRUE, prob = c(0.5, 0.25, 0.25))\n  return(sum(results)) # function returns the sum of all the spins\n}\n\nscore_per_game <- rep(0, runs) # vector to store outcome of each game\nfor (it in 1:runs) {\n  score_per_game[it] <- play_game() # play the game by calling the function\n}\nexpected_score <- mean(score_per_game) # average over all simulations\n\nprint(expected_score)#> [1] 14.45"},{"path":"solution-monte-carlo.html","id":"solution-mc-expectation-2","chapter":"Solution: Monte Carlo","heading":"4.11.2 Solution: MC Expectation 2","text":"games score zero now corresponds number games went bust (genuinely ended game zero).","code":"# simulates a game of up to 20 spins\nplay_game <- function() {\n    # picks a number from the list (1, -1, 2)\n    #  with probability 50%, 25% and 25% twenty times\n  results <- sample(c(1, -1, 2), 20, replace = TRUE, prob = c(0.5, 0.25, 0.25))\n  results_sum <- cumsum(results) # compute a running sum of points\n  # check if the game goes to zero at any point\n  if (sum(results_sum <= 0)) {\n    return(0) # return zero\n  } else {\n    return(results_sum[20]) # returns the final score\n  }\n}\n\ngame_score <- rep(0, runs) # vector to store scores in each game played\n\n# for each game\nfor (it in 1:runs) {\n  game_score[it] <- play_game()\n}\n\nprint(mean(game_score))#> [1] 9.03plot(game_score)"},{"path":"maximum-likelihood.html","id":"maximum-likelihood","chapter":"5 Maximum Likelihood","heading":"5 Maximum Likelihood","text":"lectures, saw use brute-force search parameters find maximum likelihood estimate unknown mean Normal distribution given set data. exercise, now look efficiently real life.","code":""},{"path":"maximum-likelihood.html","id":"the-likelihood-function","chapter":"5 Maximum Likelihood","heading":"5.1 The likelihood function","text":"First, going write function compute log-likelihood function given parameters:Note function returns -sum(logF) numerical optimisation algorithm going use finds minimum function. interested maximum likelihood can turn minimisation problem simply negating likelihood.Now, lets assume data captured following vector:","code":"neglogLikelihood <- function(mu, x) {\n  logF = dnorm(x, mean = mu, sd = 1, log = TRUE)\n  return(-sum(logF))\n}x = c(-0.5, 1.0, 0.2, -0.3, 0.5, 0.89, -0.11, -0.71, 1.0, -1.3, 0.84)\nn = length(x)"},{"path":"maximum-likelihood.html","id":"optimisation","chapter":"5 Maximum Likelihood","heading":"5.2 Optimisation","text":"Now, need define initial search value parameter, arbitrarily pick value:Now use R function optim find maximum likelihood estimate. mentioned , optim finds minimum value function case trying find parameter minimises negative log likelihood., says start search mu_init using function logLikelihood defined . optim algorithm use L-BFGS-B search method. parameter allowed take value lower = -Inf upper = Inf. result stored .optimiser run, can see parameter value found:can compare sample meanIt turns theoretically known maximum likelihood estimate, particular problem, sample mean coincide!can visualise . First define array possible values mu case -0.1 0.3 101 values -:use apply function apply logLikelihood function mu values defined. means need use loop:can plot overlay maximum likelihood result:plot shows optim found mu minimises negative log-likelihood.","code":"mu_init = 1.0out <- optim(mu_init, neglogLikelihood, gr = NULL, x, method = \"L-BFGS-B\",\n         lower = -Inf, upper = Inf)print(out$par)#> [1] 0.1372727print(mean(x))#> [1] 0.1372727mu <- seq(-0.1, 0.3, length = 101)neglogL <- apply( matrix(mu), 1, neglogLikelihood, x)plot(mu, neglogL, pch=\"-\")\npoints(out$par, out$value, col=\"red\", pch=0)"},{"path":"maximum-likelihood.html","id":"two-parameter-estimation","chapter":"5 Maximum Likelihood","heading":"5.3 Two-parameter estimation","text":"Now suppose mean variance Normal distribution unknown need search two parameters maximum likelihood estimation.now need modified negative log-likelihood function:Notice pass one argument theta whose elements parameters mu sigma2 unpack within function.Now can run optim time initial parameters values must initialised two values. Furthermore, variance negative, bound possible lower values sigma2 can take setting lower = c(-Inf, 0.001). second argument means sigma2 lower 0.001:can now visualise results creating two-dimensional contour plot. first need generate grid values mu sigma2:Now apply negative log-likehood function grid generate negative log-likelihood value position grid:now use contour function plot results:Excellent! now found maximum likelihood estimates unknown mean variance Normal distribution data assumed drawn . Let’s compare estimates sample mean variance. First, estimates:Now, sample mean variances:Interesting! maximum likelihood estimates return sample mean biased sample variance estimate (normalise \\(n\\)\n\\(n−1\\)). Indeed, turns theoretically, maximum likelihood estimate give biased estimate population variance.","code":"neglogLikelihood2 <- function(theta,x) {\n  mu <- theta[1] # get value for mu\n  sigma2 <- theta[2] # get value for sigma2\n\n  # compute density for each data element in x\n  logF <- dnorm(x, mean = mu, sd = sqrt(sigma2), log = TRUE)\n\n  return(-sum(logF)) # return negative log-likelihood\n}theta_init = c(1, 1)\n\nout <- optim(theta_init, neglogLikelihood2, gr = NULL, x, method = \"L-BFGS-B\",\n        lower = c(-Inf, 0.001), upper = c(Inf, Inf))# one dimensional grid of values for mu\nmu <- seq(-0.1, 1.0, length = 101)\n# one dimensional grid of values for sigma2\nsigma2 <- seq(0.1, 1.0, length = 101)\n\nmu_xx <- rep(mu, each = 101) # replicate this 101 times\nsigma2_yy <- rep(sigma2, times = 101) # replicate this 101 times\n\n# generate grid of values (each row contains a unique combination\n# of mu and sigma2 values)\nmu_sigma_grid <- cbind(mu_xx, sigma2_yy)neglogL2 <- apply(mu_sigma_grid, 1, neglogLikelihood2, x)# convert vector of negative log-likelihood values into a grid\nneglogL2 <- matrix(neglogL2, 101)\n\n# draw contour plot\ncontour(sigma2, mu, neglogL2, nlevels = 50, xlab = \"sigma2\", ylab = \"mu\")\n# overlay the maximum likelihood estimate as a red circle\npoints(out$par[2], out$par[1], col=\"red\")print(out$par[1]) # mu estimate#> [1] 0.1372727print(out$par[2]) # sigma2 estimate#> [1] 0.5569665print(mean(x)) # sample mean#> [1] 0.1372727print(var(x)) # sample variance (normalised by n-1)#> [1] 0.6126618print(var(x)*(n-1)/n) # sample variance (normalised by n)#> [1] 0.5569653"},{"path":"maximum-likelihood.html","id":"ex-mle","chapter":"5 Maximum Likelihood","heading":"5.4 Exercise: MLE","text":"potentially biased coin tossed 10 times number heads recorded. experiment repeated 5 times number heads recorded 3, 2, 4, 5 2 respectively.Can derive maximum likelihood estimate probability obtaining head?","code":""},{"path":"sol-mle.html","id":"sol-mle","chapter":"Solution: Model Answers: MLE","heading":"Solution: Model Answers: MLE","text":"potentially biased coin tossed 10 times number heads recorded. experiment repeated 5 times number heads recorded 3, 2, 4, 5 2 respectively.need choose correct pdf write likelihood function R. case, use binomial distribution. case, one ways write solution.","code":"neglogLikelihood <- function(p, n, x) {\n  # compute density for each data element in x\n  logF <- dbinom(x, n, prob = c(p, 1 - p), log = TRUE)\n  return(-sum(logF)) # return negative log-likelihood\n}\n\nn <- 10 # number of coin tosses\nx <- c(3, 2, 4, 5, 2) # number of heads observed\n\np_init <- 0.5 # initial value of the probability\n\n# run optim to get maximum likelihood estimates\nout <- optim(p_init, neglogLikelihood, gr = NULL, n, x, method = \"L-BFGS-B\",\n  lower = 0.001, upper = 1-0.001)\n\n# create a grid of probability values\np_vals <- seq(0.001, 1 - 0.001, length = 101)\n\n# use apply to compute the negative log-likelihood for each probability value\nneglogL <- apply(matrix(p_vals), 1, neglogLikelihood, n, x)\n\n# plot negative log-likelihood function and overlay maximum (negative)\n# log-likelihood estimate\nplot(p_vals, neglogL, pch = \"-\")\npoints(out$par, out$value, col = \"red\", pch = 0)"},{"path":"confidence-intervals.html","id":"confidence-intervals","chapter":"6 Confidence Intervals","heading":"6 Confidence Intervals","text":"practical session, learn derive confidence intervals particular problem using Monte Carlo simulations.random experiment, sample data collected can estimate population parameter interest. estimate can either point estimate interval estimate - range values.confidence interval interval estimate associated confidence level. confidence level tells us probability procedure used construct confidence interval result interval containing true population parameter. probability population parameter lies range.counter-intuitive concept shall now illustrate exercise.","code":""},{"path":"confidence-intervals.html","id":"setup","chapter":"6 Confidence Intervals","heading":"6.1 Setup","text":"First, create new R script within Rstudio start code preamble. use package ggplot2 plotting. can always create plot using base package plot function ggplot2 powerful plotting package use throughout course.Use install.packages(\"ggplot2\") console window package installed system. running code BearPortal already installed, use function running code machine.Lets define width interval, set 1 initially change later :","code":"library(ggplot2)interval_width <- 1 # width of confidence interval"},{"path":"confidence-intervals.html","id":"simulating-data","chapter":"6 Confidence Intervals","heading":"6.2 Simulating data","text":"now going generate simulated data experiment. create 30 samples Normal distribution mean 2.5 variance 1. true values population parameters. real experiment, know values using simulated data, obviously control .Let define first:Now, generate normally distributed data using R function rnorm,now 30 samples Normal distribution population mean 2.5 variance 1.","code":"# number of data points to generate\nn <- 30\n# population mean\nmu <- 2.5\n# population standard deviation (square root of population variance)\nsigma <- 1.0# generate n values from the  Normal distribution N(mu, sigma)\nx <- rnorm(n, mean = mu, sd = sigma)"},{"path":"confidence-intervals.html","id":"constructing-the-confidence-interval","chapter":"6 Confidence Intervals","heading":"6.3 Constructing the confidence interval","text":"going pretend know population mean value (2.5) used generate dataset try provide interval estimate simulated sample data.Remember, lectures, sample mean \\(\\bar{x}\\) natural point estimate population mean \\(\\mu\\).suitable interval might centred sample mean extend ,Let’s look interval:Q: confidence interval contain true parameter?","code":"x_bar = mean(x) # compute sample meaninterval <- c(x_bar - interval_width / 2, x_bar + interval_width / 2)print(interval)#> [1] 2.091368 3.091368"},{"path":"confidence-intervals.html","id":"experiment","chapter":"6 Confidence Intervals","heading":"6.4 Experiment","text":"previous experiment examined one simulated dataset fully understand probabilistic interpretation confidence interval just yet. moment, interval calculated either contain population mean .order understand probabilistic interpretation, need generate many data sets, construct confidence intervals see across generated data sets, often intervals cover true population mean.Monte Carlo simulation, need many repeats simulation. Lets define number repeats used:use 1000 simulations initially make code quick run may want make higher later greater accuracy.Now, let us define series interval widths simultaneously test,creates sequence values 0.1 1.0 steps 0.1 vector interval_width:Now, create vector zeros length. use store number times confidence interval specific widths contain true population meanThe hard work now begins. use loop repeat simulation nreps times. Within loop, simulate new data set, compute sample mean check confidence interval contains true population mean. Since using one confidence width, use second loop cycle different widths.can now calculate, width, estimate probability confidence interval width contain population mean.Let’s use ggplot2 plot relationship,Can see interval width \\(0.6\\) \\((\\bar{x} \\pm 0.3)\\) gives confidence interval close 90% probability containing population mean?Remember lectures saw theory says \\(\\bar{x} \\pm 1.65\\,\\frac{\\sigma}{\\sqrt{n}}\\) gives 90% confidence interval?, compute \\(2 \\times 1.65\\, \\frac{\\sigma}{\\sqrt{n}}\\), get?Monte Carlo estimate matches theory!","code":"nreps <- 1000 # number of Monte Carlo simulation runs# define a series of interval widths\ninterval_width <- seq(0.1, 1.0, 0.1)\n# store the number of interval widths generated\nn_interval_widths <- length(interval_width)print(interval_width)#>  [1] 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1.0# create a vector to store the number of times the population mean is contained\nmu_contained <- rep(0, n_interval_widths)for (replicate in 1:nreps) {\n\n  x <- sigma * rnorm(n) + mu # simulate a data set\n\n  xbar <- mean(x) # compute the sample mean\n\n  # for each interval width that we are testing ...\n  for (j in 1:n_interval_widths) {\n    # check if the interval contains the true mean\n    if ((mu > xbar - 0.5 * interval_width[j]) &\n        (mu < xbar + 0.5 * interval_width[j])) {\n      # if it is, we increment the count by one for this width\n      mu_contained[j] <- mu_contained[j] + 1\n    }\n  }\n\n}probability_mean_contained <- mu_contained / nreps# create a data frame containing the variables we wish to plot\ndf <- data.frame(interval_width = interval_width,\n                 probability_mean_contained = probability_mean_contained)\n\n# initialise the ggplot\nplt <- ggplot(df, aes(x = interval_width, y = probability_mean_contained))\n# create a line plot\nplt <- plt + geom_line()\n# add a horizontal axis label\nplt <- plt + xlab(\"Interval Width\")\n# create a vertical axis label\nplt <- plt + ylab(\"Probability that mu is contained\")\n\nprint(plt) # plot to screenprint(2 * 1.65 * sigma / sqrt(n))#> [1] 0.6024948"},{"path":"confidence-intervals.html","id":"problem-confidence-interval","chapter":"6 Confidence Intervals","heading":"6.5 Problem: Confidence Interval","text":"Can devise way compute confidence interval population standard deviation?can make use following point estimate sample variance:\\[\n  s^2 = \\frac{1}{n - 1}\\sum_{= 1}^n (x - \\bar{x})^2\n\\]can calculated using sd function R, remember relationship standard deviation variance.","code":""},{"path":"model-answer-confidence-interval.html","id":"model-answer-confidence-interval","chapter":"Model Answer: Confidence Interval","heading":"Model Answer: Confidence Interval","text":"","code":"# create a vector to store the number of times\n# the population variance is contained\nsigma_contained <- rep(0, n_interval_widths)\n\nfor (replicate in 1:nreps) {\n\n  x <- rnorm(n, mean = mu, sd = sigma) # simulate a data set\n\n  sigmabar <- sd(x) # compute the sample standard deviation\n\n  # for each interval width that we are testing ...\n  for (j in 1:n_interval_widths) {\n    # check if the interval contains the true mean\n    if ((sigma > sigmabar - 0.5 * interval_width[j]) &\n        (sigma < sigmabar + 0.5 * interval_width[j])) {\n\n      # if it is, we increment the count by one for this width\n      sigma_contained[j] <- sigma_contained[j] + 1\n    }\n  }\n}\n\nprobability_var_contained <- sigma_contained / nreps\n\n# create a data frame containing the variables we wish to plot\ndf <- data.frame(interval_width = interval_width,\n        probability_var_contained = probability_var_contained)\n\n# initialise the ggplot\nplt <- ggplot(df, aes(x = interval_width, y = probability_var_contained))\n# create a line plot\nplt <- plt + geom_line()\n# add a horizontal axis label\nplt <- plt + xlab(\"Interval Width\")\n# create a vertical axis label\nplt <- plt + ylab(\"Probability that sigma is contained\")\n\n# plot to screen\nprint(plt)print(df)#>    interval_width probability_var_contained\n#> 1             0.1                     0.288\n#> 2             0.2                     0.537\n#> 3             0.3                     0.736\n#> 4             0.4                     0.861\n#> 5             0.5                     0.942\n#> 6             0.6                     0.978\n#> 7             0.7                     0.993\n#> 8             0.8                     0.998\n#> 9             0.9                     0.999\n#> 10            1.0                     1.000"}]
