[{"path":"index.html","id":"intro","chapter":"Introduction to the Practical","heading":"Introduction to the Practical","text":"part practical module - Essentials Mathematics Statistics (EMS) part MSc Bioinformatics University Birmingham.website hosts practicals module, covers:Sampling random variableProbability RLinear regressionPrincipal Component Analysis (PCA)Multivariate RegressionGeneralised Linear Models","code":""},{"path":"index.html","id":"how-to-use-these-resources","chapter":"Introduction to the Practical","heading":"0.1 How to use these resources","text":"Section 2 covers basic concepts using R Rstudio. already covered , refresher.Section 3 contains link one locations can download data .sections contain content practical go .","code":""},{"path":"getting-started-in-r-and-rstudio.html","id":"getting-started-in-r-and-rstudio","chapter":"Getting started in R and Rstudio","heading":"Getting started in R and Rstudio","text":"already started working R, just core principles revisited. Ensure understand required knowledge covered module.","code":""},{"path":"getting-started-in-r-and-rstudio.html","id":"r-scripts","chapter":"Getting started in R and Rstudio","heading":"0.2 R scripts","text":"entering running code R command line effective simple. technique limitations. time want execute set commands, re-enter command line. Complex commands potentially subject typographical errors, necessitating re-entered correctly. Repeating set operations requires re-entering code stream. Fortunately, R RStudio provide method mitigate issues. R scripts solution. script simply text file containing set commands comments. script can saved used later re-execute saved commands. script can also edited can execute modified version commands.","code":""},{"path":"getting-started-in-r-and-rstudio.html","id":"creating-an-r-script","chapter":"Getting started in R and Rstudio","heading":"0.3 Creating an R script","text":"easy create new script RStudio. can open new empty script clicking New File icon upper left main RStudio toolbar. icon looks like white square white plus sign green circle. Clicking icon opens New File Menu. Click R Script menu option script editor open empty script.new script opens Script Editor panel, script ready text entry, RStudio session look like .easy example familiarize Script Editor interface. Type following code new script (later topics explain specific code components )., now first R script. Notice editor places number front line code. line numbers can helpful work code. proceeding executing code, good idea learn save script.","code":"\n    # this is my first R script\n    # do some things\n    x = 34\n    y = 16\n    z = x + y   # addition\n    w = y/x     # division\n    # display the results\n    x\n    y\n    z\n    w\n    # change x\n    x = \"some text\"\n    # display the results\n    x\n    y\n    z\n    w"},{"path":"getting-started-in-r-and-rstudio.html","id":"saving-an-r-script","chapter":"Getting started in R and Rstudio","heading":"0.4 Saving an R script","text":"can save script clicking Save icon top Script Editor panel. , Save File dialog open.","code":""},{"path":"getting-started-in-r-and-rstudio.html","id":"executing-code-in-an-r-script","chapter":"Getting started in R and Rstudio","heading":"0.5 Executing code in an R script","text":"can run code R script easily. Run button Script Editor panel toolbar run either current line code block selected code. can use First script.R code gain familiarity functionality.Place cursor anywhere line 3 script \\[x = 34\\]. Now press Run button Script Editor panel toolbar. Three things happen: 1) code transferred command console, 2) code executed, 3) cursor moves next line script. Press Run button three times. RStudio executes lines 4, 5, 6 script.Now run set code commands . Highlight lines 8, 9, 10, 11 script.Highlighting accomplished similar may familiar word processor applications. click left mouse button beginning text want highlight, hold mouse button drag cursor end text release button. four lines code highlighted, click editor Run button. four lines code executed command console. takes run script code RStudio.","code":""},{"path":"getting-started-in-r-and-rstudio.html","id":"comments-in-an-r-script-documenting-your-code","chapter":"Getting started in R and Rstudio","heading":"0.5.1 Comments in an R script (documenting your code)","text":"finishing topic, one final concept understand. always good idea place comments code. help understand code meant . become helpful reopen code wrote weeks ago trying work . saying, “Real programmers document code. hard write, hard understand” meant dark joke, coding style guide.comment R code begins # symbol. code First script.R contains several examples comments. Lines 1, 2, 7, 12, 14 image comment lines. line text starts # treated comment ignored code execution. Lines 5 6 image contain comments end. text # treated comment ignored execution.Notice RStudio editor shows comments colored green. green color helps focus code get confused comments.Besides using comments help make R code easily understood, can use # symbol ignore lines code developing code stream. Simply place # front line want ignore. R treat lines comments ignore . want include lines code execution, remove # symbols code executable . technique allows change code execute without retype deleted code.","code":""},{"path":"data-sets.html","id":"data-sets","chapter":"Data sets","heading":"Data sets","text":"practical datasets required, find data required week two practicals data folder . Links individual datasets requried can found beginning practical Canvas.\n","code":""},{"path":"simulating-random-numbers.html","id":"simulating-random-numbers","chapter":"1 Simulating random numbers","heading":"1 Simulating random numbers","text":"number functions R can use simulate random numbers according different probability distributions.function sample allows take sample specified size elements vector xusing sampling without replacement. can use ?sample read documentation describing command.following, use sample function make 10,000 draws set numbers 1, 2, 3 4 display distribution sampled values using histogram.First, define vector called x contains numbers 1, 2, 3, 4. function c allows us combine four numbers together one vector:now use function sample pick four numbers x 10,000 times. result, 10,000 numbers chosen, store :Lets plot histogram values picked:picked number equal probability histogram shows number equally likely chosen.ProblemWhat difference output out1 out2 following piece code?option replace=TRUE activates sampling replacement (.e. numbers picked put back can picked ).option replace=FALSE activates sampling without replacement (.e. numbers picked put back picked ).ProblemUse sample sample.int function simulate values rolls unbiased six-sided die. Show distribution values obtain consistent unbiased die.Hint 1: Type ?sample.int console get help function.Hint 2: may find useful use function table. Type ?table console get help function.gives uniform distribution numbers 1-6. function sample.int specialised version sample sampling integers. Many R libraries specialised versions general functions specific tasks certain conditions.","code":"\nx <- c(1, 2, 3, 4)\nout <- sample(x, 10000, replace=TRUE)\nhist_out <- hist(out, main = '', xlab = 'Values', ylab = 'Frequency')\nx <- c( 1, 2, 2, 3, 4, 1, 6, 7, 8, 10, 5, 5, 1, 4, 9 )\nout1 <- sample(x, 10, replace=FALSE)\nout2 <- sample(x, 10, replace=TRUE)\nrolls_from_sample = sample(c(1:6), size=5000, replace=TRUE)\nrolls_from_sample.int = sample(6, size=5000, replace=TRUE)\n\ntable(rolls_from_sample)\n#> rolls_from_sample\n#>   1   2   3   4   5   6 \n#> 806 833 815 852 850 844\ntable(rolls_from_sample.int)\n#> rolls_from_sample.int\n#>   1   2   3   4   5   6 \n#> 813 864 825 813 832 853"},{"path":"markov-chains.html","id":"markov-chains","chapter":"2 Markov Chains","heading":"2 Markov Chains","text":"now look Markov Chain. covered lectures based basic principles covered able use simulations.random process known Markov property (Markov process) probability going next state depends current state past states. Markov process memoryless property store property memory past states.Markov process operates within specific (finite) set states, called Markov Chain.Markov Chain defined three properties:state space: set values states process existA state space: set values states process existA transition matrix: defines probability moving one state another stateA transition matrix: defines probability moving one state another stateA current state probability distribution: defines probability one states start processA current state probability distribution: defines probability one states start processConsider following example two states describing weather particular day: () Sunny (ii) Rainy. arrow denotes probability going one state another course day. example, currently sunny, probability raining next day 0.6. Conversely, raining, probability become sunny next day 0.7 0.3 continue raining.transition matrix can written following R:creates 2 x 2 matrix consisting transition probabilities shown diagram.Suppose want simulate sequence 30 days weather patterns days. Assuming day 0 currently sunny, can following:ProblemCan extend example three-state model?Note, diagram (intentionally) misses self-transitions. able infer probabilities given otherwise add one!","code":"\ntransitionMatrix = matrix(c(0.4, 0.6, 0.7, 0.3), nrow=2, ncol=2, byrow=TRUE)\nprint(transitionMatrix)\n#>      [,1] [,2]\n#> [1,]  0.4  0.6\n#> [2,]  0.7  0.3\n# initial state - it is [1] sunny or [2] rainy\nstate <- 1\nweather_sequence <- rep(0, 30) # vector to store simulated values\nfor (day in 1:30) { # simulate for 30 days\n  pr <- transitionMatrix[state, ] # select the row of transition probabilities\n\n  # sample [1] or [2] based on the probs pr\n  state = sample(c(1, 2), size = 1, prob = pr)\n  weather_sequence[day] <- state # store the sampled state\n}\n\n# print the simulated weather sequence\nprint(weather_sequence)\n#>  [1] 1 2 1 1 1 2 1 1 2 1 2 2 2 1 2 1 2 1 1 2 2 1 2 1 1 2 1 2\n#> [29] 2 1"},{"path":"markov-chains.html","id":"model-answers-3-state-markov-chain","chapter":"2 Markov Chains","heading":"Model answers 3 state Markov Chain","text":"Set 3x3 transition matrix:Note ordering states arbitrary used convention State 1 Sunny, State 2 Rainy State 3 Cloudy means probabilities completed order transition matrix. just need consistent.","code":"\ntransitionMatrix = matrix(c(0.7, 0.2, 0.1,\n                            0.3, 0.3, 0.4,\n                            0.6, 0.2, 0.2), nrow=3, ncol=3, byrow=TRUE)\n\n# Check matrix set-up correctly\nprint(transitionMatrix)\n#>      [,1] [,2] [,3]\n#> [1,]  0.7  0.2  0.1\n#> [2,]  0.3  0.3  0.4\n#> [3,]  0.6  0.2  0.2\nstate <- 1 # initial state - it is [1] sunny, [2] rainy and [3] cloudy\nweather_sequence <- rep(0, 30) # vector to store simulated values\n\n# simulate for 30 days\nfor (day in 1:30) {\n  pr <- transitionMatrix[state, ] # select the row of transition probabilities\n\n  # sample [1-3] based on the probs pr\n  state <- sample(c(1, 2, 3), size = 1, prob = pr)\n  weather_sequence[day] <- state # store the sampled state\n}\nprint(weather_sequence)\n#>  [1] 1 1 1 1 2 1 1 1 2 3 1 1 3 1 1 1 2 2 3 1 1 2 1 1 2 3 3 1\n#> [29] 1 1"},{"path":"markov-chains.html","id":"a-monopoly-simulation","chapter":"2 Markov Chains","heading":"2.1 A Monopoly simulation","text":"Now use simulate simplified games Monopoly (https://en.wikipedia.org/wiki/Monopoly_(game)). addition, also many tutorials guides Web describing produce computer simulations Monopoly. welcome read use examples inspire work.","code":""},{"path":"markov-chains.html","id":"moving-around-the-board","chapter":"2 Markov Chains","heading":"2.2 Moving around the board","text":"Monopoly board 40 spaces. Players take turns roll two dice traverse around board according sum dice values.Use following code example simulate turns single player:increasing number turns taken, distribution set simulated board positions converge towards? Show graphically using histogram function.","code":"\nnum_turns <- 100000 # number of turns to take\n\ncurrent_board_position <- 0 # start on the GO space\n\nmove_size <- rep(0, num_turns)\npositions_visited <- rep(0, num_turns)\n\n# use a for loop to simulate a number of turns\nfor (turn in 1:num_turns) {\n\n  # roll two dice\n  die_values <- sample(c(1:6), 2, replace = TRUE)\n\n  # move player position\n\n  # number of positions to move\n  plus_move <- sum(die_values)\n\n  # compute new board position\n  new_board_position <- current_board_position + plus_move\n\n  # update board position (this corrects for the fact the board is circular)\n  current_board_position <- (new_board_position %% 40)\n\n  # store position visited\n  positions_visited[turn] <- current_board_position\n\n}\nhist(positions_visited, breaks = seq(0, 40, len = 41), right = FALSE)"},{"path":"markov-chains.html","id":"going-to-jail","chapter":"2 Markov Chains","heading":"2.3 Going to Jail","text":"player lands Go Jail space must move immediately Jail space. Extend code include possibility going jail. , assume jail, player continues normal next turn.distribution board positions long game?Can explain result qualitatively?can also go jail, roll three doubles (dice value) row. Update code allow possibility going Jail three doubles. distribution board positions change?Adding rolling doubles feature doesn’t seem change much. might expect since rolling three doubles unlikely event!","code":"\n num_turns <- 100000 # number of turns to take\n\ncurrent_board_position <- 0 # start on the GO space\ngo_to_jail_position <- 30 # the go to jail space\njail_position <- 10 # jail space\n\nmove_size <- rep(0, num_turns)\npositions_visited <- rep(0, num_turns)\n\n# use a for loop to simulate a number of turns\nfor (turn in 1:num_turns) {\n\n  # roll two dice\n  die_values <- sample(c(1:6), 2, replace = TRUE)\n\n  # move player position\n\n  # number of positions to move\n  plus_move <- sum(die_values)\n\n  # compute new board position\n  new_board_position <- current_board_position + plus_move\n\n  # if land on GO TO JAIL square, then go backwards to the JAIL square\n  if (new_board_position == go_to_jail_position) {\n    new_board_position <- jail_position\n  }\n\n  # update board position (this corrects for the fact the board is circular)\n  current_board_position <- (new_board_position %% 40)\n\n  # store position visited\n  positions_visited[turn] <- current_board_position\n\n}\nhist(positions_visited, breaks = seq(0, 40, len = 41), right = FALSE)\nnum_turns <- 100000 # number of turns to take\n\ncurrent_board_position <- 0 # start on the GO space\ngo_to_jail_position  <- 30 # the go to jail space\njail_position <- 10 # jail space\n\nmove_size <- rep(0, num_turns)\npositions_visited <- rep(0, num_turns)\n\n# use a for loop to simulate a number of turns\nfor (turn in 1:num_turns) {\n\n  # set double counter to zero\n  double_counter <- 0\n\n  # roll (max) three times\n  for (j in 1:3){\n\n    # roll two dice\n    die_values <- sample(c(1:6), 2, replace = TRUE)\n\n    # if we have rolled a double for the third time, we proceed straight to jail\n    if ((die_values[1] == die_values[2]) & (double_counter == 2 )) {\n      current_board_position <- jail_position\n      break\n    }\n\n    # otherwise\n\n    # move player position\n\n    # number of positions to move\n    plus_move <- sum(die_values)\n\n    # compute new board position\n    new_board_position <- current_board_position + plus_move\n\n    # if land on GO TO JAIL square, then go backwards to the JAIL square\n    if (new_board_position == go_to_jail_position) {\n      new_board_position <- jail_position\n    }\n\n    # update board position (this corrects for the fact the board is circular)\n    current_board_position <- (new_board_position %% 40)\n\n    # break out of loop if we roll a non-double\n    if (die_values[1] != die_values[2]) {\n      break\n    } else { # increment double counter\n      double_counter <- double_counter + 1\n    }\n\n  }\n\n  # store final position visited\n  positions_visited[turn] <- current_board_position\n\n\n}\n\n\nhist(positions_visited, breaks = seq(0, 40, len = 41), right = FALSE)"},{"path":"markov-chains.html","id":"further-exercises","chapter":"2 Markov Chains","heading":"2.4 Further Exercises","text":"Now consider building complex Monopoly simulation incorporating complex aspects game :purchase propertiesa ledger playerchance community cardsYou need think carefully simplifying assumptions make make task achievable. -ambitious. example, might initially assume players build houses/hotels properties.questions answer simulations:many turns take properties purchased?best properties buy?long take winner determined?example, following simple extension previous example adds features record properties purchased. simulation constructed based assumption players always buys free property land .","code":"\nnum_games <- 1000 # number of games to play\nnum_turns <- 1000 # number of turns to take\n\ncurrent_board_position <- 0 # start on the GO space\ngo_to_jail_position <- 30 # the go to jail space\njail_position <- 10 # jail space\n# vector of squares containing properties\nproperties_that_can_be_bought <- c(1, 3, 5, 6, 8, 9, 11, 12, 13, 14, 15, 16,\n   18, 19, 21, 23, 24, 25, 26, 27, 28, 29, 31, 32, 34, 35, 37, 39)\n\n\n# vector to store number of turns to buy all properties\ntime_to_buy_all_properties <- rep(0, num_games)\n\n# simulate multiple games\nfor (game in 1:num_games) {\n\n  positions_visited <- rep(0, num_turns)\n  positions_purchased <- rep(0, 40)\n  properties_bought <- rep(0, num_turns)\n\n  # use a for loop to simulate a number of turns\n  for (turn in 1:num_turns) {\n\n    # roll two dice\n    die_values <- sample(c(1:6), 2, replace = TRUE)\n\n    # move player position\n\n    # number of positions to move\n    plus_move <- sum(die_values)\n\n    # compute new board position\n    new_board_position <- current_board_position + plus_move\n\n    # if land on GO TO JAIL square, then go backwards to the JAIL square\n    if (new_board_position == go_to_jail_position) {\n      new_board_position <- jail_position\n    }\n\n    # update board position (this corrects for the fact the board is circular)\n    current_board_position <- (new_board_position %% 40)\n\n    # if we can on a square that can be purchased and which has not been\n    # purchased (note R uses 1-indexing for arrays)\n    if (positions_purchased[current_board_position+1] == 0) {\n      if (current_board_position %in% properties_that_can_be_bought) {\n        positions_purchased[current_board_position + 1] <- 1\n      }\n    }\n\n    # store position visited\n    positions_visited[turn] <- current_board_position\n\n    # store number of properties bought\n    properties_bought[turn] <- sum(positions_purchased)\n\n    # check if all properties are gone\n    if (properties_bought[turn] == length(properties_that_can_be_bought)) {\n      time_to_buy_all_properties[game] <- turn\n      break\n    }\n\n\n  }\n\n}\n\nhist(time_to_buy_all_properties, breaks = 20)"}]
